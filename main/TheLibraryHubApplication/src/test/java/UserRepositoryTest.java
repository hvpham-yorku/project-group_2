import org.example.User;
import org.example.UserRepository;

import org.junit.jupiter.api.BeforeEach;
import org.junit.jupiter.api.Test;
import org.mockito.Mock;
import org.mockito.Mockito;
import java.sql.*;

import static org.junit.jupiter.api.Assertions.*;
import static org.mockito.Mockito.*;

// THIS CLASS IS GENERATED BY DEEPSEEK BUT DOES NOT WORK
class UserRepositoryTest {

    @Mock private UserRepository userRepository;
    @Mock private Connection mockConnection;
    @Mock private PreparedStatement mockStatement;
    @Mock private ResultSet mockResultSet;

    @BeforeEach
    void setUp() throws Exception {
        userRepository = new UserRepository();

        mockConnection = mock(Connection.class);
        mockStatement = mock(PreparedStatement.class);
        mockResultSet = mock(ResultSet.class);

        when(mockConnection.prepareStatement(anyString())).thenReturn(mockStatement);
    }

    @Test
    void testCreateUser() throws Exception {
        User user = new User("John", "Doe", "john123", "password");

        when(mockStatement.executeUpdate()).thenReturn(1);

        userRepository.createUser(user); // This will print output, which we won't assert here.

        verify(mockStatement, times(1)).setString(1, "John");
        verify(mockStatement, times(1)).setString(2, "Doe");
        verify(mockStatement, times(1)).setString(3, "john123");
        verify(mockStatement, times(1)).setString(4, "password");
        verify(mockStatement, times(1)).setString(5, "usr"); // Default admin password for regular users
        verify(mockStatement, times(1)).executeUpdate();
    }

    @Test
    void testCreateUser_SQLException() throws Exception {
        User user = new User("John", "Doe", "john123", "password");

        when(mockStatement.executeUpdate()).thenThrow(new SQLException("Database error"));

        assertThrows(SQLException.class, () -> userRepository.createUser(user));
    }

    @Test
    void testValidateUser() throws Exception {
        when(mockResultSet.next()).thenReturn(true);
        when(mockResultSet.getString("firstName")).thenReturn("Alice");
        when(mockResultSet.getString("lastName")).thenReturn("Smith");
        when(mockResultSet.getString("username")).thenReturn("alice123");
        when(mockResultSet.getString("password")).thenReturn("mypassword");

        when(mockStatement.executeQuery()).thenReturn(mockResultSet);

        User user = userRepository.validateUser("alice123", "mypassword");

        assertNotNull(user);
        assertEquals("Alice", user.getFirstName());
        assertEquals("Smith", user.getLastName());
        assertEquals("alice123", user.getUsername());
        assertEquals("mypassword", user.getPassword());
    }

    @Test
    void testValidateUser_InvalidCredentials() throws Exception {
        when(mockResultSet.next()).thenReturn(false);
        when(mockStatement.executeQuery()).thenReturn(mockResultSet);

        User user = userRepository.validateUser("invalidUser", "wrongPass");

        assertNull(user);
    }

    @Test
    void testValidateUser_SQLException() throws Exception {
        when(mockStatement.executeQuery()).thenThrow(new SQLException("Database error"));

        assertThrows(SQLException.class, () -> userRepository.validateUser("alice123", "mypassword"));
    }

    @Test
    void testValidateUser_MultipleUsers() throws Exception {
        when(mockResultSet.next()).thenReturn(true, false); // Simulate only one user in the result set
        when(mockResultSet.getString("firstName")).thenReturn("Alice");
        when(mockResultSet.getString("lastName")).thenReturn("Smith");
        when(mockResultSet.getString("username")).thenReturn("alice123");
        when(mockResultSet.getString("password")).thenReturn("mypassword");

        when(mockStatement.executeQuery()).thenReturn(mockResultSet);

        User user = userRepository.validateUser("alice123", "mypassword");

        assertNotNull(user);
        assertEquals("Alice", user.getFirstName());
        assertEquals("Smith", user.getLastName());
        assertEquals("alice123", user.getUsername());
        assertEquals("mypassword", user.getPassword());
    }

    @Test
    void testValidateUser_NullUsernameOrPassword() throws Exception {
        User user = userRepository.validateUser(null, "mypassword");
        assertNull(user);

        user = userRepository.validateUser("alice123", null);
        assertNull(user);
    }

    @Test
    void testValidateUser_EmptyUsernameOrPassword() throws Exception {
        User user = userRepository.validateUser("", "mypassword");
        assertNull(user);

        user = userRepository.validateUser("alice123", "");
        assertNull(user);
    }

    @Test
    void testValidateUser_IncorrectPassword() throws Exception {
        when(mockResultSet.next()).thenReturn(true);
        when(mockResultSet.getString("firstName")).thenReturn("Alice");
        when(mockResultSet.getString("lastName")).thenReturn("Smith");
        when(mockResultSet.getString("username")).thenReturn("alice123");
        when(mockResultSet.getString("password")).thenReturn("mypassword");

        when(mockStatement.executeQuery()).thenReturn(mockResultSet);

        User user = userRepository.validateUser("alice123", "wrongPass");

        assertNull(user);
    }

    @Test
    void testValidateUser_IncorrectUsername() throws Exception {
        when(mockResultSet.next()).thenReturn(true);
        when(mockResultSet.getString("firstName")).thenReturn("Alice");
        when(mockResultSet.getString("lastName")).thenReturn("Smith");
        when(mockResultSet.getString("username")).thenReturn("alice123");
        when(mockResultSet.getString("password")).thenReturn("mypassword");

        when(mockStatement.executeQuery()).thenReturn(mockResultSet);

        User user = userRepository.validateUser("wrongUser", "mypassword");

        assertNull(user);
    } 
}